# 쿠키 세션 JWT

## Cookie

- 브라우저에 저장
- 요청자 구분 및 일부 데이터 저장을 위해 사용
- Key Value 형태
- 서버가 클라이언트에 저장하고자 하는 정보를 응답 헤더(cookie)에 저장하여 전달 (직접 ID/PWD를 매번 전달할 필요X)
- 이후 클라이언트는 헤더에 쿠키를 set 하여 요청
- 단점: 쿠키 노출이 쉬워 보안에 안좋음, 조작 가능, 브라우저 간의 공유 불가능, 쿠키 사이즈 제한

## Session

- 쿠키에서 ID/PWD 같은 민감정보가 그대로 노출되는 문제를 보완하기 위해 나온 개념
- ID/PWD를 직접 주고받지 말고 인증 정보 자체를 특정 세션 저장소에 저장 및 클라이언트에 세션ID 반환
- 사용자는 위의 세션ID를 쿠키에 담아 서버에 요청을 보내고 인증이 필요한 경우 API에서 해당 세션ID가 세션 저장소에 있는지 확인 후 API 처리함
- 만약 보안 문제가 발생하면 서버의 세션 저장소를 전부 지우면 됨, 이렇게 하면 세션ID로 접근해도 인증 불가
- 단점: Session은 세션ID를 저장하기 때문에 HTTP의 장점인 stateless를 위배=> stateless를 위배하는 stateful이기 때문에 서버를 늘리고 싶어도(scale-out) 세션ID 정보가 scale-out 이전 서버에 있어 따로 또 세션ID를 저장해야 하는 번거로움 존재

## JWT

- 인터넷 표준 인증 방식으로 인증에 필요한 정보들을 Token에 담아 암호화 시킴
- 추후 사용자가 서버에 토큰을 헤더에 포함해서 서버에 전송하면 복잡한 인증 과정 없이 토큰만으로 사용자 인증 가능
- 토큰에 필요한 모든 정보가 들어있어서 stateless 하고 MSA에 유용
- JWT 구성요소: Header.Payload.Signature
- Header: 토큰 타입, 알고리즘 (ex. JWT, AES256)
- Payload: 토큰에 담기는 주체, 만료일, 생성자 정보 등을 담는다.
- Signature: 위변조 방지를 위해 개인키를 통한 전자서명 존재
- 순서
  1. 사용자가 ID/PWD를 서버에 넘겨 로그인 요청
  2. 서버는 비밀키를 통해서 서명을 하고 공개키로 암호화 시킨 Access Token을 발급 후 사용자에게 전달
  3. 사용자는 API 호출 시 Authorization Header에 Access Token을 담아서 전송
  4. 서버에서 사용자가 보낸 토큰을 secret key로 복호화하여 유효한 토큰인지 확인
  5. 토큰 확인이 잘 되면 서버가 요청에 대한 응답을 사용자에게 전달
  - Refresh Token: Access Token이 너무 길면 탈취 당했을 때 위험하므로 Access Token의 유효기간은 짧게, RefreshToken의 유효기간은 상대적으로 길게해서 Access Token이 만료되면 Refresh Token으로 다시 발급 받을 수 있게 함
- 용어
  1. 서명: 비밀키로 암호화
  2. 검증: 공개키를 받아서 signature 부분을 복호화하여 기존의 Payload와 header와 값이 같은지 비교

## 타 시스템과 연동 시 SSO 관련 내용

- IV 사용 이유: CBC는 동일한 값을 암호화하면 동일한 결과가 나오므로 복호화 키를 유추하기 쉽다는 문제를 해결하기 위해 나온 방식, 이때 값을 무작위로 변경시켜주는게 IV, 그런데 IV를 고정으로 쓰면 의미없음
- AES256: 대칭키 알고리즘
- 내부망을 통해 통신하는 사내 시스템, 같은 실 아래 있기 때문에 간단히 하기 위해 공개키 방식 대신 대칭키 방식으로 진행
- C#에서 System.Security.Cryptography 를 이용하여 암호화/복호화 진행